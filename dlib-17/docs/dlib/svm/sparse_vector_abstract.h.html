<html><!-- Created using the cpp_pretty_printer from the dlib C++ library.  See http://dlib.net for updates. --><head><title>dlib C++ Library - sparse_vector_abstract.h</title></head><body bgcolor='white'><pre>
<font color='#009900'>// Copyright (C) 2009  Davis E. King (davis@dlib.net)
</font><font color='#009900'>// License: Boost Software License   See LICENSE.txt for the full license.
</font><font color='#0000FF'>#undef</font> DLIB_SVm_SPARSE_VECTOR_ABSTRACT_
<font color='#0000FF'>#ifdef</font> DLIB_SVm_SPARSE_VECTOR_ABSTRACT_

<font color='#0000FF'>#include</font> <font color='#5555FF'>&lt;</font>cmath<font color='#5555FF'>&gt;</font>
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../algs.h.html'>../algs.h</a>"
<font color='#0000FF'>#include</font> "<a style='text-decoration:none' href='../serialize.h.html'>../serialize.h</a>"

<font color='#0000FF'>namespace</font> dlib
<b>{</b>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <a name='sparse_vectors'/><font color='#009900'>/*!A sparse_vectors
        In dlib, sparse vectors are represented using the container objects
        in the C++ STL.  In particular, a sparse vector is any container that 
        contains a sorted range of std::pair&lt;key, scalar_value&gt; objects where:
            - key is an unsigned integral type 
            - scalar_value is float, double, or long double

        So examples of valid sparse vectors are:    
            - std::map&lt;unsigned long, double&gt;
            - std::vector&lt;std::pair&lt;unsigned long, float&gt; &gt; where the vector is sorted.
              (you could make sure it was sorted by applying std::sort to it)


        This file defines a number of helper functions for doing normal vector
        arithmetic things with sparse vectors.
    !*/</font>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <a name='has_unsigned_keys'/><font color='#009900'>/*!A has_unsigned_keys

        This is a template where has_unsigned_keys&lt;T&gt;::value == true when T is a
        sparse vector that contains unsigned integral keys and false otherwise.
    !*/</font>

    <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
    <font color='#0000FF'>struct</font> <b><a name='has_unsigned_keys'></a>has_unsigned_keys</b>
    <b>{</b>
        <font color='#0000FF'>static</font> <font color='#0000FF'>const</font> <font color='#0000FF'><u>bool</u></font> value <font color='#5555FF'>=</font> is_unsigned_type<font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T::value_type::first_type<font color='#5555FF'>&gt;</font>::value;
    <b>}</b>;

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <font color='#0000FF'>namespace</font> sparse_vector
    <b>{</b>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance_squared'></a>distance_squared</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
                - b is a sorted range of std::pair objects
            ensures
                - returns the squared distance between the vectors
                  a and b
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U, <font color='#0000FF'>typename</font> V, <font color='#0000FF'>typename</font> W<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance_squared'></a>distance_squared</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> V<font color='#5555FF'>&amp;</font> a_scale,
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> W<font color='#5555FF'>&amp;</font> b_scale,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
                - b is a sorted range of std::pair objects
            ensures
                - returns the squared distance between the vectors
                  a_scale*a and b_scale*b
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance'></a>distance</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
                - b is a sorted range of std::pair objects
            ensures
                - returns the distance between the vectors
                  a and b.  (i.e. std::sqrt(distance_squared(a,b)))
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U, <font color='#0000FF'>typename</font> V, <font color='#0000FF'>typename</font> W<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='distance'></a>distance</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> V<font color='#5555FF'>&amp;</font> a_scale,
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> W<font color='#5555FF'>&amp;</font> b_scale,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
                - b is a sorted range of std::pair objects
            ensures
                - returns the distance between the vectors
                  a_scale*a and b_scale*b.  (i.e. std::sqrt(distance_squared(a_scale,a,b_scale,b)))
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='assign'></a>assign</b> <font face='Lucida Console'>(</font>
            T<font color='#5555FF'>&amp;</font> dest,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> src
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - dest == a sparse vector or a dense vector
                - src == a sparse vector or a dense vector
                - dest is not dense when src is sparse
                  (i.e. you can't assign a sparse vector to a dense vector.  This is
                  because we don't know what the proper dimensionality should be for the
                  dense vector)
            ensures
                - #src represents the same vector as dest.  
                  (conversion between sparse/dense formats is done automatically)
        !*/</font>


    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a and b are valid sparse vectors (as defined at the top of this file).
            ensures
                - returns the dot product between the vectors a and b
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a valid sparse vector (as defined at the top of this file).
                - is_vector(b) == true
            ensures
                - returns the dot product between the vectors a and b
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> EXP<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='dot'></a>dot</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> matrix_exp<font color='#5555FF'>&lt;</font>EXP<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> b
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - b is a valid sparse vector (as defined at the top of this file).
                - is_vector(a) == true
            ensures
                - returns the dot product between the vectors a and b
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='length_squared'></a>length_squared</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
            ensures
                - returns dot(a,a) 
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>typename</font> T::value_type::second_type <b><a name='length'></a>length</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> a
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
            ensures
                - returns std::sqrt(length_squared(a,a))
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>void</u></font> <b><a name='scale_by'></a>scale_by</b> <font face='Lucida Console'>(</font>
            T<font color='#5555FF'>&amp;</font> a,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> value
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - a is a sorted range of std::pair objects
            ensures
                - #a == a*value
                  (i.e. multiplies every element of the vector a by value)
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'><u>unsigned</u></font> <font color='#0000FF'><u>long</u></font> <b><a name='max_index_plus_one'></a>max_index_plus_one</b> <font face='Lucida Console'>(</font>
            <font color='#0000FF'>const</font> T<font color='#5555FF'>&amp;</font> samples
        <font face='Lucida Console'>)</font>; 
        <font color='#009900'>/*!
            requires
                - samples == a single vector (either sparse or dense), or a container
                  of vectors which is either a dlib::matrix of vectors or something 
                  convertible to a dlib::matrix via vector_to_matrix() (e.g. a std::vector)
                    Value types of samples include (but are not limited to):
                        - dlib::matrix&lt;double,0,1&gt;                      // A single dense vector 
                        - std::map&lt;unsigned int, double&gt;                // A single sparse vector
                        - std::vector&lt;dlib::matrix&lt;double,0,1&gt; &gt;        // An array of dense vectors
                        - std::vector&lt;std::map&lt;unsigned int, double&gt; &gt;  // An array of sparse vectors
            ensures
                - This function tells you the dimensionality of a set of vectors.  The vectors
                  can be either sparse or dense.  
                - if (samples.size() == 0) then
                    - returns 0
                - else if (samples contains dense vectors or is a dense vector) then
                    - returns the number of elements in the first sample vector.  This means
                      we implicitly assume all dense vectors have the same length)
                - else
                    - In this case samples contains sparse vectors or is a sparse vector.  
                    - returns the largest element index in any sample + 1.  Note that the element index values
                      are the values stored in std::pair::first.  So this number tells you the dimensionality
                      of a set of sparse vectors.
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'><u>long</u></font> NR, <font color='#0000FF'><u>long</u></font> NC, <font color='#0000FF'>typename</font> MM, <font color='#0000FF'>typename</font> L, <font color='#0000FF'>typename</font> SRC, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='add_to'></a>add_to</b> <font face='Lucida Console'>(</font>
            matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> dest,
            <font color='#0000FF'>const</font> SRC<font color='#5555FF'>&amp;</font> src,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> C <font color='#5555FF'>=</font> <font color='#979000'>1</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SRC == a matrix expression or a sparse vector
                - is_vector(dest) == true
                - max_index_plus_one(src) &lt;= dest.size()
            ensures
                - #dest == dest + C*src
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
        <font color='#0000FF'>template</font> <font color='#5555FF'>&lt;</font><font color='#0000FF'>typename</font> T, <font color='#0000FF'><u>long</u></font> NR, <font color='#0000FF'><u>long</u></font> NC, <font color='#0000FF'>typename</font> MM, <font color='#0000FF'>typename</font> L, <font color='#0000FF'>typename</font> SRC, <font color='#0000FF'>typename</font> U<font color='#5555FF'>&gt;</font>
        <font color='#0000FF'>inline</font> <font color='#0000FF'><u>void</u></font> <b><a name='subtract_from'></a>subtract_from</b> <font face='Lucida Console'>(</font>
            matrix<font color='#5555FF'>&lt;</font>T,NR,NC,MM,L<font color='#5555FF'>&gt;</font><font color='#5555FF'>&amp;</font> dest,
            <font color='#0000FF'>const</font> SRC<font color='#5555FF'>&amp;</font> src,
            <font color='#0000FF'>const</font> U<font color='#5555FF'>&amp;</font> C <font color='#5555FF'>=</font> <font color='#979000'>1</font>
        <font face='Lucida Console'>)</font>;
        <font color='#009900'>/*!
            requires
                - SRC == a matrix expression or a sparse vector
                - is_vector(dest) == true
                - max_index_plus_one(src) &lt;= dest.size()
            ensures
                - #dest == dest - C*src
        !*/</font>

    <font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
    <b>}</b>

<font color='#009900'>// ----------------------------------------------------------------------------------------
</font>
<b>}</b>

<font color='#0000FF'>#endif</font> <font color='#009900'>// DLIB_SVm_SPARSE_VECTOR_ABSTRACT_
</font>



</pre></body></html>